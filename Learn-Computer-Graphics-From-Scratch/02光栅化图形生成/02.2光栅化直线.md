# 光栅化直线

## 准备

我们先编写好创建ppm文件以及写入ppm文件的程序

我们将使用fstream读写ppm文件

```cpp
#include <iostream>
#include <fstream>
int main(){
    
    return 0;
}
```

定义好图片的尺寸以及分配颜色值的内存

```cpp
// 定义图片的尺寸
int width = 256;
int height = 256;

// 分配颜色值存储
int size = width * height;
int *r = new int[size];
int *g = new int[size];
int *b = new int[size];
```

size就是我们的像素个数，每个像素各自拥有rgb三个分量的颜色值，一共有size个像素，所以每个颜色值分量也就有size个

我们设置每个像素的颜色为红色

```cpp
  // 设置像素的颜色值
    for (int y = 0; y < height; ++y)
    {
        for (int x = 0; x < width; ++x)
        {
            int idx = y * width + x;
            r[idx] = 255;
            g[idx] = 0;
            b[idx] = 0;
        }
    }
```

因为图片一般是由坐上角为原点，从左到右从上到下写数据的，所以我们也这样设置颜色值，如果不这样做到时候写入文件的时候像素就是乱的。

由于我们是用一维数组存放数据的，但是图片是二维的所以我们需要做一个简单的转化 y * width + x;

创建PPM文件

```cpp
    std::ofstream f("output.ppm");
    if (!f)
    {
        std::cerr << "Error: Cannot open file for writing." << std::endl;
        return 1;
    }
```

按照PPM格式P3模式写入文件

```cpp
 f << "P3\n"
      << width << ' ' << height << "\n255\n";
    for (int i = 0; i < size; ++i)
    {
        f << r[i] << ' ' << g[i] << ' ' << b[i] << ' ';
    }
    f << '\n';
```

最后释放内存就好了

```cpp
	delete[] r;
    delete[] g;
    delete[] b;
```

此时代码是这样的

```cpp
#include <iostream>
#include <fstream>

int main()
{
    // 定义图片的尺寸
    int width = 256;
    int height = 256;

    // 分配颜色值存储
    int size = width * height;
    int *r = new int[size];
    int *g = new int[size];
    int *b = new int[size];

    // 设置像素的颜色值
    for (int y = 0; y < height; ++y)
    {
        for (int x = 0; x < width; ++x)
        {
            int idx = y * width + x;
            r[idx] = 255;
            g[idx] = 0;
            b[idx] = 0;
        }
    }

    // 创建PPM文件
    std::ofstream f("output.ppm");
    if (!f)
    {
        std::cerr << "Error: Cannot open file for writing." << std::endl;
        return 1;
    }

    // 写入PPM文件
    f << "P3\n"
      << width << ' ' << height << "\n255\n";
    for (int i = 0; i < size; ++i)
    {
        f << r[i] << ' ' << g[i] << ' ' << b[i] << ' ';
    }
    f << '\n';

    std::cout << "PPM image written to output.ppm" << std::endl;

    
    delete[] r;
    delete[] g;
    delete[] b;

    return 0;
}
```

![上程序渲染图片]()

### 优化

优化程序更易使用

```cpp
#include <iostream>
#include <string>
#include <fstream>

static const int width = 256;
static const int height = 256;
int size = width * height;

int *r = new int[size];
int *g = new int[size];
int *b = new int[size];

void SetPixel(int x, int y, int ColorR, int ColorG, int ColorB)
{
    int index = x + y * width;
    r[index] = ColorR;
    g[index] = ColorG;
    b[index] = ColorB;
}

bool Render(std::string filename)
{
    std::ofstream f(filename);
    if (!f)
    {
        std::cerr << "Error: Cannot open file for writing." << std::endl;
        return false;
    }

    f << "P3\n"
      << width << ' ' << height << "\n255\n";
    for (int i = 0; i < size; ++i)
    {
        f << r[i] << ' ' << g[i] << ' ' << b[i] << ' ';
    }
    f << '\n';

    std::cout << "PPM image written to output.ppm" << std::endl;
    return true;
}

int main()
{

    for (int y = 0; y < height; ++y)
    {
        for (int x = 0; x < width; ++x)
        {
            SetPixel(x, y, 255, 0, 0);
        }
    }
    Render("output.ppm");

    delete[] r;
    delete[] g;
    delete[] b;
    return 0;
}
```

# **Bresenham** 画线算法

我们都知道两个点可以确定一条线，那么画一条线至少需要两个点

但是如何用离散的像素精确的拟合这条线呢？

Bersenham画线算法是这样的

- 计算斜率k
- middle = 0.5 
- middle =  delta>=middle? middle +1 :middle
- x = x+1,y = delta>=middle? y+1:y

