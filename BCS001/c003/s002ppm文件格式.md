## **PPM 文件格式**

作为现代开发者，**想直接控制屏幕上的每一个像素其实并不容易**。出于安全性和多任务管理的考虑，操作系统通常不会允许应用程序随意改写屏幕像素。虽然我们可以通过图形 API（如 OpenGL、Vulkan 等）间接实现像素级控制——别担心，我将在其他系列中详细介绍这些技术——但本着“如无必要，勿增实体”的原则，我们暂不引入复杂的图形接口。

取而代之，我们将通过直接操作图像文件中的每个像素来学习渲染原理。本质上，只要我们能精确控制像素的颜色值，就能绘制出任何想要的图形。

为此，我们选择使用 **PPM（Portable Pix map）格式**。这是一种极其简单的图像格式，广泛应用于计算机图形学的教学与实验中。PPM 格式有两种常见的编码方式：

- **P3 模式**：ASCII 文本格式，以十进制数字明文存储 RGB 值
- **P6 模式**：二进制格式，以字节形式存储 RGB 值
- 注意：PPM 格式不支持 Alpha 通道，仅包含 RGB 三个颜色分量。

### **P3 模式示例**

```
# 文件首行指定格式标识符
P3
# 第二行指定图像宽度和高度（以空格分隔）
2 2
# 第三行指定颜色最大值（通常为 255）
255
# 后续按从左到右、从上到下的顺序列出每个像素的 R G B 值
255 0 0   255 0 0
255 0 0   255 0 0
```

### **P6 模式介绍**

P6 是 PPM 的二进制版本，结构与 P3 类似，但像素数据以**二进制字节流**形式存储，因此文件体积更小、读写效率更高。

其文件结构如下：

```
P6
<width> <height>
<maxval>
<binary pixel data>
```

其中：

- `<width>` 和 `<height>` 仍以 ASCII 文本表示；
- `<maxval>` 通常为 255，表示每个颜色通道的最大值；
- 之后紧跟的是原始的 RGB 字节序列，每个像素占 3 个字节（R、G、B 各 1 字节），按行优先顺序排列。

通过使用 PPM，我们可以在不依赖任何图形库的情况下，专注于理解光栅化、着色、几何变换等核心图形学概念。接下来，我们将基于此格式编写自己的微型渲染器。

我们提供了最了小的ppm库方便创建图片，以及使用示例。

所有的代码都在相同章节相同小节的目录下的code目录下，我们不考虑教程的储存大小所以我们为每节都配备了相应的代码，你可以直接获得与本节同步的代码。
