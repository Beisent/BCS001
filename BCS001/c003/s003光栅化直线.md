# 光栅化直线

注意：这一节其实不是很重要，了解即可

我们这里说的直线其实是线段，当你看到这里时你会怎么光栅化一条线段？你如果不仔细思考，就会想到设计出这么一个算法说：这还不简单然后给出这么一个算法。

```C++
void draw_old_line(uint32_t x0, uint32_t y0, uint32_t x1, uint32_t y1)
{
    uint32_t width = 300;
    uint32_t height = 300;

    lcg::PPM ppm(".", "old_line", width, height);

    float k = (float)(y1 - y0) / (x1 - x0);
    std::vector<uint8_t> data(width * height * 3, 0);

    for (uint32_t x = x0; x <= x1; ++x)
    {
        uint32_t y = static_cast<uint32_t>(k * (x - x0) + y0);

        data[(y * width + x) * 3 + 0] = 255; // R
        data[(y * width + x) * 3 + 1] = 255; // G
        data[(y * width + x) * 3 + 2] = 255; // B
    }

    ppm.setData(data);
    std::cout << "创建 old_line.ppm 成功" << std::endl;
}
```

这个算法有以下问题

1. 只能画从左到右的线，当x0 > x1的时候，循环根本不会执行
2. 不能画竖线，此时x0 == x1 程序会崩溃
3. 不能画陡峭的线，此时你每遍历一个 x，y的跳跃很大会产生线条断裂，不连续

## DDA算法

 **DDA（Digital Differential Analyzer）算法**  是一种递增的算法。

我们可以每次在原来的点上加上一个值（偏移量）得到下一个点，渲染下一个点再继续下一轮。那么我们加上的这个值是多少？

我们可以给 $x_i$ 加上 偏移量
$$
x_{inc} = \frac{x_1-x_0}{max(|x_1-x_0|,|y_1-y_0|)}
$$
给 $ y_i$ 加上 偏移量
$$
y_{inc} = \frac{y_1-y_0}{max(|x_1-x_0|,|y_1-y_0|)}
$$
我来解释一下为什么偏移量是这个

给  $y_i,x_i$  加上  $y_{inc},x_{inc}$  偏移量可以解决问题1和3，同时我们不使用斜率k所以没有问题2。

我们先解释为什么可以解决问题3，因为我们取得是x轴上两点距离与y轴上两点距离上的最大值，再让其对应的距离除以该最大值，这会产生什么？当最大值是 $|x_1-x_0|$ 此时 $x_{inc} == 1$ $y_{inc} <= 1$ 我们此时对需要渲染的点 $x_i,y_i$ 加上该偏移量，此时 $y_i,x_i$ 都是浮点数 $x_i$ 在这种情况下都是整数，$ y_i$可能是浮点数我们对其四舍五入，如果四舍了那么  $ y_i$ 与上次一样，如果五入了那么此时 $ y_{i+1} = y_i \pm 1$ 。总的来说在此时的状态下，下一个点的位置是 $(x_i\pm1,y_i)$或者$(x_i\pm1,y_i\pm 1)$。问题1被解决是因为 $x_1-x_0$ 和 $y_1-y_0$ 提供了偏移的方向。最大值是 $|y_1-y_0|$同理。 

所以据此我们可以实现DDA算法

```c++
void draw_dda_line(uint32_t x0, uint32_t y0, uint32_t x1, uint32_t y1)
{
    uint32_t width = 300;
    uint32_t height = 300;

    lcg::PPM ppm(".", "dda_line", width, height);
    std::vector<uint8_t> data(width * height * 3, 0);

    int dx = (int)x1 - (int)x0;
    int dy = (int)y1 - (int)y0;

    int steps = std::max(abs(dx), abs(dy));

    float x_inc = dx / (float)steps;
    float y_inc = dy / (float)steps;

    float x = x0;
    float y = y0;

    for (int i = 0; i <= steps; ++i)
    {
        int xi = (int)std::round(x);
        int yi = (int)std::round(y);

        if (xi >= 0 && xi < width && yi >= 0 && yi < height)
        {
            data[(yi * width + xi) * 3 + 0] = 255;
            data[(yi * width + xi) * 3 + 1] = 255;
            data[(yi * width + xi) * 3 + 2] = 255;
        }

        x += x_inc;
        y += y_inc;
    }

    ppm.setData(data);
    std::cout << "创建 dda_line.ppm 成功" << std::endl;
}
```

## Bresenham算法

这个算法看上去很完美了，但是还是有不足的地方，这个算法中有很多浮点运算，浮点运算比整数运算慢很多，所以贪婪的人类还找到了一种只用整数运算实现的算法。

DDA算法的核心的偏移量，不过DDA的偏移量可以是浮点数。而且他是基于递增的。那么如果我们提取出其核心思想，对于下一个点，其 x 值到底是 $\pm 1$ 还是不变， 其 y 值到底是 $\pm 1$ 还是不变。解决这个问题之后我们就实现了 Bresenham 算法了。

我们先考虑一种特殊情况，当斜率是 0 < k < 1 ，x0 < x1时此时斜率对于 y 来说变化不是很大。

所以此时此时我们每次都让 x 增加 1：x = x0, x0+1, x0+2, ...

而 y 有两种可能选择：y或者y+1

我们要做的事情就是在这两个y中选一个，使其最接近真实直线。

**直线的一般方程是**：$F(x,y) = dy\cdot x-dx\cdot y+C = 0$

在这种情况下对于一个点平面上

-  $A (x_i,y_i)$ $F(x_i,y_i)>0$，A直线F上方
-  $A (x_i,y_i)$ $F(x_i,y_i)<0$，A直线F下方
-  $A (x_i,y_i)$ $F(x_i,y_i)=0$，A直线F上

所以我们选择当前点的的下一个位置的中间点作为参考，即对当前 $(x_i,y_i)$ 的下一个点中间点$M (x_i+1,y_i+0.5)$ 

- 如果 M 在直线下方，说明真实直线更靠近右上像素即$(x_i+1,y_i+1)$；
- 如果 M 在直线上方，说明更靠近正右像素$(x_i+1,y_i)$。

#### 定义决策变量

$$
d = F(x_i+1，y_i+0.5) = 	(x_i+1)dy-(y_i+0.5)dx+C
$$

假设我们下一个点是 $x_{i+1}=x_i+1,y_{i+1}=y_i$ 

则我们的决策变量是
$$
d_{next} = F(x_i+2，y_i+0.5) = 	(x_i+2)dy-(y_i+0.5)dx+C
$$
整理
$$
d_{next} = d+dy
$$
假设我们下一个点是 $x_{i+1}=x_i+1,y_{i+1}=y_i+1$ 

则我们的决策变量是
$$
d_{next} = F(x_i+2，y_i+1.5) = 	(x_i+2)dy-(y_i+1.5)dx+C
$$
整理
$$
d_{next} = d+dy-dx
$$
所以我们的公式就变成了

- $d_{next} = d+dy$ 当下一个点是 $x_{i+1}=x_i+1,y_{i+1}=y_i$ 
- $d_{next} = d+dy-dx$ 当下一个点是 $x_{i+1}=x_i+1,y_{i+1}=y_i+1$ 

所以据此我们可以实现Bersenham算法
